/*
 * CODE MAITRE - GANT (AFFICHAGE LIVE ACTIF)
 * Envoie à : 20:E7:C8:68:55:E4
 */
#include <Wire.h>
#include <esp_now.h>
#include <WiFi.h>

// --- ADRESSE MAC DE TON ESCLAVE ---
uint8_t broadcastAddress[] = {0x20, 0xE7, 0xC8, 0x68, 0x55, 0xE4}; 

// --- Configuration I2C MPU6500 ---
const int MPU_ADDR = 0x68; 
const int SDA_PIN = 21;
const int SCL_PIN = 22;

// --- Structure des données ---
typedef struct struct_message {
  int8_t moveDirX; // -1, 0, 1
  int8_t moveDirY; 
} struct_message;

struct_message myData;
esp_now_peer_info_t peerInfo;

// --- Filtre de Kalman ---
class Kalman {
public:
    Kalman() {
        Q_angle = 0.001f; Q_bias = 0.003f; R_measure = 0.03f;
        angle = 0.0f; bias = 0.0f;
        P[0][0] = 0.0f; P[0][1] = 0.0f; P[1][0] = 0.0f; P[1][1] = 0.0f;
    };
    float getAngle(float newAngle, float newRate, float dt) {
        rate = newRate - bias;
        angle += dt * rate;

        P[0][0] += dt * (dt*P[1][1] - P[0][1] - P[1][0] + Q_angle);
        P[0][1] -= dt * P[1][1];
        P[1][0] -= dt * P[1][1];
        P[1][1] += Q_bias * dt;

        float S = P[0][0] + R_measure;
        float K[2];
        K[0] = P[0][0] / S; K[1] = P[1][0] / S;

        float y = newAngle - angle;
        angle += K[0] * y;
        bias += K[1] * y;

        float P00_temp = P[0][0]; float P01_temp = P[0][1];
        P[0][0] -= K[0] * P00_temp; P[0][1] -= K[0] * P01_temp;
        P[1][0] -= K[1] * P00_temp; P[1][1] -= K[1] * P01_temp;

        return angle;
    };
private:
    float Q_angle, Q_bias, R_measure;
    float angle, bias, rate;
    float P[2][2];
};

Kalman kalmanX;
Kalman kalmanY;

// Variables globales
uint32_t timer;
int16_t accX, accY, accZ;
int16_t gyroX, gyroY, gyroZ;
float gyroXrate, gyroYrate;
float kalAngleX, kalAngleY;

// --- I2C ---
void i2c_write(int reg, int data) {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(reg);
    Wire.write(data);
    Wire.endTransmission();
}

void i2c_read_sensor() {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x3B); 
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_ADDR, 14, 1);

    accX = Wire.read() << 8 | Wire.read();
    accY = Wire.read() << 8 | Wire.read();
    accZ = Wire.read() << 8 | Wire.read();
    int16_t temp = Wire.read() << 8 | Wire.read(); 
    gyroX = Wire.read() << 8 | Wire.read();
    gyroY = Wire.read() << 8 | Wire.read();
    gyroZ = Wire.read() << 8 | Wire.read();
}

void setup() {
    Serial.begin(115200);
    
    Wire.begin(SDA_PIN, SCL_PIN);
    Wire.setClock(400000); 

    i2c_write(0x6B, 0x00); // Réveil MPU

    WiFi.mode(WIFI_STA);
    if (esp_now_init() != ESP_OK) return;

    memcpy(peerInfo.peer_addr, broadcastAddress, 6);
    peerInfo.channel = 0;  
    peerInfo.encrypt = false;
    esp_now_add_peer(&peerInfo);

    timer = micros();
}

void loop() {
    i2c_read_sensor();
    float dt = (float)(micros() - timer) / 1000000; 
    timer = micros();

    // Calculs Angles
    float accAngleX = atan2(accY, accZ) * RAD_TO_DEG;
    float accAngleY = atan2(-accX, sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG;

    gyroXrate = gyroX / 131.0; 
    gyroYrate = gyroY / 131.0; 

    kalAngleX = kalmanX.getAngle(accAngleX, gyroXrate, dt);
    kalAngleY = kalmanY.getAngle(accAngleY, gyroYrate, dt);

    // --- LOGIQUE SERVOS ---
    if (kalAngleX > 30) myData.moveDirX = 1; 
    else if (kalAngleX < -30) myData.moveDirX = -1; 
    else myData.moveDirX = 0; 

    if (kalAngleY > 30) myData.moveDirY = 1; 
    else if (kalAngleY < -30) myData.moveDirY = -1;
    else myData.moveDirY = 0;

    esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));

    // --- AFFICHAGE LIVE ---
    // Format: "X:valeur Y:valeur"
    Serial.print("X:"); 
    Serial.print(kalAngleX);
    Serial.print(" Y:"); 
    Serial.println(kalAngleY);

    delay(20); // Légèrement ralenti (20ms) pour rendre la lecture plus agréable
}
