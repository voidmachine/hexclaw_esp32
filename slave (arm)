/*
 * CODE MAITRE - GANT (MPU6500 I2C Brut + Kalman + ESP-NOW)
 * Cible : ESP32 Esclave (Servos) à l'adresse 20:E7:C8:68:55:E4
 */
#include <Wire.h>
#include <esp_now.h>
#include <WiFi.h>

// --- ADRESSE MAC DE TON ESCLAVE ---
uint8_t broadcastAddress[] = {0x20, 0xE7, 0xC8, 0x68, 0x55, 0xE4}; 

// --- Configuration I2C MPU6500 ---
const int MPU_ADDR = 0x68; // Adresse par défaut (si AD0 est low ou non connecté)
const int SDA_PIN = 21;
const int SCL_PIN = 22;

// --- Structure des données à envoyer ---
typedef struct struct_message {
  int8_t moveDirX; // -1: Antihoraire, 0: Hold, 1: Horaire
  int8_t moveDirY; 
} struct_message;

struct_message myData;
esp_now_peer_info_t peerInfo;

// --- Classe Filtre de Kalman (Compacte) ---
class Kalman {
public:
    Kalman() {
        Q_angle = 0.001f; // Bruit de processus (accel)
        Q_bias = 0.003f;  // Dérive du bias
        R_measure = 0.03f; // Bruit de mesure
        angle = 0.0f;
        bias = 0.0f;
        P[0][0] = 0.0f; P[0][1] = 0.0f;
        P[1][0] = 0.0f; P[1][1] = 0.0f;
    };
    float getAngle(float newAngle, float newRate, float dt) {
        rate = newRate - bias;
        angle += dt * rate;

        P[0][0] += dt * (dt*P[1][1] - P[0][1] - P[1][0] + Q_angle);
        P[0][1] -= dt * P[1][1];
        P[1][0] -= dt * P[1][1];
        P[1][1] += Q_bias * dt;

        float S = P[0][0] + R_measure;
        float K[2];
        K[0] = P[0][0] / S;
        K[1] = P[1][0] / S;

        float y = newAngle - angle;
        angle += K[0] * y;
        bias += K[1] * y;

        float P00_temp = P[0][0];
        float P01_temp = P[0][1];

        P[0][0] -= K[0] * P00_temp;
        P[0][1] -= K[0] * P01_temp;
        P[1][0] -= K[1] * P00_temp;
        P[1][1] -= K[1] * P01_temp;

        return angle;
    };
private:
    float Q_angle, Q_bias, R_measure;
    float angle, bias, rate;
    float P[2][2];
};

Kalman kalmanX;
Kalman kalmanY;

// Variables globales
uint32_t timer;
int16_t accX, accY, accZ;
int16_t gyroX, gyroY, gyroZ;
float gyroXrate, gyroYrate;
float kalAngleX, kalAngleY;

// --- Fonctions I2C bas niveau ---
void i2c_write(int reg, int data) {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(reg);
    Wire.write(data);
    Wire.endTransmission();
}

void i2c_read_sensor() {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x3B); // Registre de départ (ACCEL_XOUT_H)
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_ADDR, 14, 1);

    // Lecture bit-shift
    accX = Wire.read() << 8 | Wire.read();
    accY = Wire.read() << 8 | Wire.read();
    accZ = Wire.read() << 8 | Wire.read();
    int16_t temp = Wire.read() << 8 | Wire.read(); // On vide le buffer de la température
    gyroX = Wire.read() << 8 | Wire.read();
    gyroY = Wire.read() << 8 | Wire.read();
    gyroZ = Wire.read() << 8 | Wire.read();
}

// Callback optionnel pour confirmer l'envoi
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  // Tu peux décommenter ceci pour debugger si les paquets partent bien
  // Serial.print("\r\nStatus envoi: ");
  // Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Succes" : "Echec");
}

void setup() {
    Serial.begin(115200);
    
    // Init I2C
    Wire.begin(SDA_PIN, SCL_PIN);
    Wire.setClock(400000); // 400kHz I2C

    // IMPORTANT: Réveiller le MPU6500 (le registre 0x6B est en sleep par défaut)
    i2c_write(0x6B, 0x00); 

    // Init ESP-NOW
    WiFi.mode(WIFI_STA);
    if (esp_now_init() != ESP_OK) {
        Serial.println("Erreur init ESP-NOW");
        return;
    }

    // Enregistrement du callback d'envoi (optionnel mais utile)
    esp_now_register_send_cb(OnDataSent);
    
    // Configuration du pair (Esclave)
    memcpy(peerInfo.peer_addr, broadcastAddress, 6);
    peerInfo.channel = 0;  
    peerInfo.encrypt = false;
    
    if (esp_now_add_peer(&peerInfo) != ESP_OK){
        Serial.println("Echec ajout peer");
        return;
    }

    timer = micros();
}

void loop() {
    i2c_read_sensor();

    // Calcul dt (delta time) en secondes
    float dt = (float)(micros() - timer) / 1000000; 
    timer = micros();

    // 1. Calcul des angles bruts via Accéléromètre (trigo)
    // Attention : selon comment ton MPU est monté sur le gant, tu devras peut-être intervertir X/Y/Z
    float accAngleX = atan2(accY, accZ) * RAD_TO_DEG;
    float accAngleY = atan2(-accX, sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG;

    // 2. Conversion Gyro en degrés/seconde
    gyroXrate = gyroX / 131.0; 
    gyroYrate = gyroY / 131.0; 

    // 3. Fusion des données via Kalman
    // On suppose ici que l'axe Gyro X correspond à l'axe Accel X
    kalAngleX = kalmanX.getAngle(accAngleX, gyroXrate, dt);
    kalAngleY = kalmanY.getAngle(accAngleY, gyroYrate, dt);

    // --- LOGIQUE DE SEUILS (+/- 30 degrés) ---
    
    // Axe X -> Servo 0
    if (kalAngleX > 30) {
        myData.moveDirX = 1; // Sens Horaire
    } else if (kalAngleX < -30) {
        myData.moveDirX = -1; // Sens Antihoraire
    } else {
        myData.moveDirX = 0; // Hold
    }

    // Axe Y -> Servo 1
    if (kalAngleY > 30) {
        myData.moveDirY = 1; 
    } else if (kalAngleY < -30) {
        myData.moveDirY = -1;
    } else {
        myData.moveDirY = 0;
    }

    // Envoi des ordres
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &myData, sizeof(myData));

    // Debugging : Affiche les angles pour vérifier l'orientation
    // Serial.print("AngX: "); Serial.print(kalAngleX);
    // Serial.print(" | AngY: "); Serial.println(kalAngleY);

    delay(10); // 10ms = ~100Hz rafraichissement, très fluide
}
